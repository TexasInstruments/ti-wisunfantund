<!--
    Copyright (c) 2015-2019, Texas Instruments Incorporated
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

    *   Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
    *   Neither the name of Texas Instruments Incorporated nor the names of
        its contributors may be used to endorse or promote products derived
        from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
    OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
    OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
    EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-tabs/paper-tabs.html">
<link rel="import" href="../paper-tabs/paper-tab.html">
<link rel="import" href="../paper-tabs-vertical/paper-tab-vertical.html">
<link rel="import" href="../paper-tabs-vertical/paper-tabs-vertical.html">
<link rel="import" href="../paper-material/paper-material.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../iron-pages/iron-pages.html">
<link rel="import" href="../ti-core-assets/ti-core-assets.html">
<link rel="import" href="../ti-core-icons/ti-core-icons.html" async>
<link rel="import" href="../fa-icons/fa-icons.html" async>
<link rel="import" href="../ti-widget-common-behaviors/ti-widget-tabcontainer-behavior.html">

<!--
`ti-widget-vtabcontainer` is an tabbed container widget to host child widgets in different tabs.

Example:

    <ti-widget-vtabcontainer>
        <ti-widget-tab name="tab1"></ti-widget-tab>
        <ti-widget-tab name="tab2"></ti-widget-tab>
    </ti-widget-vtabcontainer>

See demo for a full working example of how to use this component.

@group Ti Elements
@element ti-widget-tab
@demo demo.html
@homepage ../../../ti-guicomposer-helpindex/demo.html
-->
<dom-module id='ti-widget-vtabcontainer'  >

    <template>
        <style is="custom-style">
            :host {
                display : inline-block;
                text-decoration: inherit;
                position : relative;
            }
            paper-tabs, iron-pages {
                position: relative;
                height: 100%;
            }
            #layoutDiv {
                width: 100%;
                height: 100%;
                position: relative;
            }
            .flex-horizontal {
                @apply(--layout-horizontal);
                width: 100%;
                height: 100%;
                position: relative;
            }
            .flex-vertical {
                @apply(--layout-vertical);
            }
            .flexchild-vertical {
                @apply(--layout-flex);
            }
            #vtabs {
                --paper-tabs-selection-bar-color: transparent;
            }
            .htab-icon {
                left:0px;
                width: 50px;
                height: 20px;
                position: relative;
            }
            .htab-label {
                height: 25px;
                padding-bottom: 35px;
                left:0;
                overflow-x: visible;
                position: relative;
                white-space: normal;
                text-align: left;
            }
            .htab-div{
                left: 5px;
                height: 25px;
                padding-top: 15px;
                padding-bottom: 15px;
                position: relative;
                overflow-x: visible;
            }
            #childTabLayoutDiv {
                left: 40px;
                width: 100%;
                position: absolute;
            }
            .ptv {
                left:0;
                position: relative;
                @apply(--layout-self-start);
                transition-property: height;
                transition-duration: 0.5s;
                min-height:50px;
            }
            .vtab-label {
                margin: 15px;
                margin-right: 0;
                height: 25px;
                padding-bottom: 35px;
                left:0;
                overflow-x: visible;
                position: relative;
                white-space: normal;
                text-align: left;
            }

        </style>
        <div id="layoutDiv" class="layout horizontal">
            <template id="splashTemplate" is="dom-if" restamp if="{{!isInitComplete}}">
                <div id="splash" style="top:0;bottom:0;left:0;right:0;z-index:999999;background-color:#eeeeee;position: absolute;">
                    <div style="width: 100%; height: 100%; background: url('./images/loading.gif') no-repeat center"></div>
                </div>
            </template>
            <template id="mainTemplate" is="dom-if" restamp if="{{_isVisible(hideVtabLabels,_refreshCtr)}}">
                <div id="layoutDiv2">
                    <!-- configure attr-for-selected to nonexistent label property so that selectedIndex is not updated by iron-multiselectable-behavior, which does not
                         take into consideration tabs which are not visible.  This component's own _vtabClickHdlr will handle setting selectedIndex -->
                    <paper-tabs-vertical id="vtabs" selected="{{selectedLabel}}" attr-for-selected="label" no-bar class="container flex-vertical designAction" style="height:100%;">
                        <template id="tab_template" is="dom-repeat" restamp items="{{_vtabLabels}}" as="label" index-as="vtab_index" >
                            <template is="dom-if" restamp if="[[_isVtabVisible(vtab_index,_refreshCtr)]]">
                                <paper-tab-vertical label="[[label]]" id$="tab_[[vtab_index]]" on-mousedown="_vtabClickHdlr" tabindex="[[_getTabIndex(vtab_index,isExpanded,_refreshCtr)]]" class="ptv" style$="[[_getVtabStyle(vtab_index,selectedIndex,vtabHeightInPx,isExpanded,_refreshCtr)]]" noink="{{noInk}}" ink-color="{{inkColor}}" >
                                    <template is="dom-if" restamp if="{{_isVtabIcon(vtab_index,_refreshCtr)}}">
                                        <iron-icon id$="icon_[[vtab_index]]" icon="{{_getVtabIcon(vtab_index,_refreshCtr)}}" on-mouseover="_overStyle" on-mouseout="_outStyle" style$="{{_getVtabIconStyle(vtab_index,selectedIndex,colorSelected,colorUnselected,colorDisabled,isExpanded,_refreshCtr)}};" title="[[_getVtabTooltip(vtab_index)}}"></iron-icon>
                                        <template is="dom-if" restamp if="{{isExpanded}}">
                                            <span class="vtab-label" style$="[[_getVtabMenuStyle(vtab_index,selectedIndex,_refreshCtr)]]" title="[[_getVtabTooltip(vtab_index)}}">{{label}}</span>
                                        </template>
                                        <template is="dom-if" restamp if="{{isExpanded}}">
                                            <div id="childTabLayoutDiv" class="layout vertical" >
                                                <template is="dom-repeat" items="{{_getHtabItems(vtab_index,_vtabLabels,_refreshCtr)}}" as="htab" index-as="htab_index">
                                                    <div id$="htab_[[vtab_index]].[[htab_index]]" on-mousedown="_htabClickHdlr" class="htab-div flexchild-vertical">
                                                        <template is="dom-if" if="{{_isHtabIcon(htab,htab_index)}}">
                                                            <iron-icon id$="icon_[[vtab_index]].[[htab_index]]" class="htab-icon" icon="{{htab.icon}}" style$="right:0;{{_getHtabStyle(vtab_index,selectedIndex,colorSelected,colorUnselected,colorDisabled,_vtabLabels,vtabHeightInPx,htab,htab_index,_refreshCtr)}};" on-mousedown="_htabClickHdlr" title="[[_getHtabTooltip(vtab_index,htab_index)}}"></iron-icon>
                                                        </template>
                                                        <template is="dom-if" if="{{isExpanded}}">
                                                        <span id$="label_[[vtab_index]].[[htab_index]]" class="htab-label" style$="right:0;{{_getHtabStyle(vtab_index,selectedIndex,colorSelected,colorUnselected,colorDisabled,_vtabLabels,vtabHeightInPx,htab,htab_index,_refreshCtr)}};" title="[[_getHtabTooltip(vtab_index,htab_index)}}">
                                                            <ti-widget-label label="{{htab.name}}"  on-mousedown="_htabClickHdlr" font-color="{{_getHtabFontColor(vtab_index,selectedIndex,htab_index,colorSelected,colorUnselected,colorDisabled,_refreshCtr)}}"></ti-widget-label>
                                                        </span>
                                                        </template>
                                                    </div>
                                                </template>
                                            </div>
                                        </template>
                                    </template>
                                </paper-tab-vertical>
                            </template>
                        </template>
                    </paper-tabs-vertical>
                </div>
            </template>
            <iron-pages id="vtabPages" restamp selected="{{selectedIndex}}" class="flex" items-selector="ti-widget-vtab" style$="{{_getIronPagesStyle(hideVtabLabels,_refreshCtr)}}">
                    <slot></slot>
            </iron-pages>
        </div>
    </template>
    <script>

        Polymer ({
            is: 'ti-widget-vtabcontainer',
            /**
             * Fired when the selected tab index is about to be changed
             * - The event.detail object contains the current selectedIndex and selectedLabel values object before selectedLabel is updated.
             *  - To receive the callback, add the attribute on-before-selected_tab_changed="myHandler" as an attribute to this component's tag
             * or in javascript, use templateObj.$.<componentId>.addEventListener("before_selected_tab_changed",function(event){...});
             *
             * @event before_selected_tab_changed
             */
            /**
             * Fired when the user changes the selected tab index
             * - The event.detail object contains selectedIndex and selectedLabel values object.
             *  - To receive the callback, add the attribute on-selected_tab_changed="myHandler" as an attribute to this component's tag
             * or in javascript, use templateObj.$.<componentId>.addEventListener("selected_tab_changed",function(event){...});
             *
             * @event selected_tab_changed
             */
            /**
             * Fired when the user clicks a vertical tab
             * - The event.detail object contains a vtabIndex property which indicates which tab was clicked.
             *  - To receive the callback, add the attribute on-vtab_click="myHandler" as an attribute to this component's tag
             * or in javascript, use templateObj.$.<componentId>.addEventListener("vtab_click",function(event){...});
             *
             * @event vtab_click
             */
            /**
             * Fired when the user clicks a child (horizontal) tab
             * - The event.detail object contains an tabIndex property which indicates which tab was clicked.
             *  - To receive the callback, add the attribute on-tab_click="myHandler" as an attribute to the child component's tag
             * or in javascript, use templateObj.$.<componentId>.addEventListener("tab_click",function(event){...});
             *
             * @event tab_click
             */
            /**
             * Fired when the user selects a tab with the fireAppResetWhenSelected property set to true
             *
             * @event app_reset
             */

            properties: {
                /**
                 * Controls the currently selected tab by zero based index.
                 *
                 * @attribute selectedIndex
                 * @type number
                 * @default -1
                 */
                selectedIndex: {
                    notify: true,
                    type: Number,
                    value: -1,
                    observer: "_selectedIndexChanged"
                },

                /**
                 * Controls the currently selected tab by label.
                 *
                 * @attribute selectedLabel
                 * @type string
                 * @default undefined
                 */
                selectedLabel: {
                    notify: true,
                    type: String,
                    value: undefined,
                    observer: "_selectedLabelChanged"
                },
                /**
                 * background color of the icon of the selected vertical tab
                 *
                 * @attribute backgroundColorSelected
                 * @type String
                 * @default "#d9f4f8"
                 */
                backgroundColorSelected: {
                    notify: true,
                    type: String,
                    value: "#d9f4f8",
                    observer: "refreshStyles"
                },
                /**
                 * background color of the icon of the vertical tab when the mouse is over it
                 *
                 * @attribute backgroundColorHpver
                 * @type String
                 * @default "#dcdcec"
                 */
                backgroundColorHover: {
                    notify: true,
                    type: String,
                    value: "#dcdcec",
                    observer: "refreshStyles"
                },
                /**
                 * color of the icon of the selected vertical tab
                 *
                 * @attribute colorSelected
                 * @type String
                 * @default "#000"
                 */
                colorSelected: {
                    notify: true,
                    type: String,
                    value: "#000"
                },
                /**
                 * color of the icon of unselected vertical tabs
                 *
                 * @attribute colorUnselected
                 * @type String
                 * @default "#888"
                 */
                colorUnselected: {
                    notify: true,
                    type: String,
                    value: "#888"
                },
                /**
                 * color of the icon of disabled vertical tabs
                 *
                 * @attribute colorDisabled
                 * @type String
                 * @default "#ccc"
                 */
                colorDisabled: {
                    notify: true,
                    type: String,
                    value: "#ccc"
                },
                /**
                 * color of the selection bar
                 *
                 * @attribute colorSelectionBar
                 * @type String
                 * @default "#fff"
                 */
                colorSelectionBar: {
                    notify: true,
                    type: String,
                    value: "#fff"
                },
                _vtabItems: {
                    notify: false,
                    type: Array,
                    value: function(){return [];}
                },
                _vtabLabels: {
                    notify: false,
                    type: Array,
                    value: function(){return [];}
                },
                _vtabIcons: {
                    notify: false,
                    type: Array,
                    value: function(){return [];}
                },
                _vtabIconStyles: {
                    notify: false,
                    type: Array,
                    value: function(){return [];}
                },
                _vtabCaptions: {
                    notify: false,
                    type: Array,
                    value: function(){return [];}
                },
                _vtabTooltips: {
                    notify: false,
                    type: Array,
                    value: function(){return [];}
                },
                _refreshCtr: {
                    notify: false,
                    type: Number,
                    value: 0
                },
                /**
                 * set to true to hide the tab labels at the top of the tab containers e.g. if you will be controlling
                 * the selection via javascript or a vertical tab menubar
                 */
                hideVtabLabels: {
                    notify: false,
                    type: Boolean,
                    value: false
                },

                /**
                 * If true, ink ripple effect is disabled.
                 *
                 * @attribute noInk
                 * @type Boolean
                 * @default false
                 */
                noInk: {
                    notify: true,
                    type: Boolean,
                    value: false
                },
                /**
                 * Color of the ink ripple effect (if enabled)
                 *
                 * @attribute inkColor
                 * @type String
                 * @default "#f1f1f1"
                 */
                inkColor: {
                    notify: true,
                    type: String,
                    value:  "#f1f1f1"
                },
                /**
                 * if > 0, specifies a fixed height for each vertical tab.
                 * if <= 0, the vtabs are spread evenly across the vertical height of the tab container
                 *
                 * @attribute vtabHeightInPx
                 * @type Number
                 * @default -1
                 */
                vtabHeightInPx: {
                    notify: true,
                    type: Number,
                    value: -1
                },
                /**
                 * if true, the menu is expanded to show the child horizontal tab pages for each vertical tab
                 *
                 * @attribute isExpanded
                 * @type Boolean
                 * @default false
                 */
                isExpanded: {
                    notify: true,
                    type: Boolean,
                    value: false,
                    observer: "_isExpandedChanged"
                },
                /**
                 * if true, the menu is automatically expanded when the vertical tab icon
                 * is clicked and the page associated with the icon contains child horizontal tab pages
                 *
                 * @attribute autoExpand
                 * @type Boolean
                 * @default true
                 */
                autoExpand: {
                    notify: true,
                    type: Boolean,
                    value: true
                },
                /**
                 * if autoExpand is false and autoZeroHtabIndex is true, if the child of the selected vtab is
                 * a ti-widget-tabcontainer the selectedIndex of the ti-widget-tabcontainer is automatically
                 * reset to zero so that the home page is automatically displayed.  Set this to false if
                 * the ti-widget-tabcontainer is used for displaying route info such as device-specific info
                 * based on a selected device.
                 *
                 * @attribute autoZeroHtabIndex
                 * @type Boolean
                 * @default false
                 */
                autoZeroHtabIndex: {
                    notify: true,
                    type: Boolean,
                    value: false
                },
                /**
                 * Set to true once all configuration of the vertical tabs has been complete.  The splash image
                 * is displayed while isInitcomplete is false
                 *
                 * @attribute isInitComplete
                 * @type Boolean
                 * @default false
                 */
                isInitComplete: {
                    notify: true,
                    type: Boolean,
                    value: false,
                    observer: "_isInitCompleteChanged"
                }
            },
            behaviors: [TiWidgetTabcontainerBehavior],

            _getTabItems: function(){
                return this._vtabItems;
            },
            _isVisible: function(hideVtabLabels,_refreshCtr){
                return !hideVtabLabels;
            },
            _domReadyWasCalled: false,
            childFilter: function(element){
                var result = false;
                if ((element) && (element.localName === 'ti-widget-vtab')){
                    result = true;
                }
                return result;
            },
            /** Change the style **/
            _overStyle: function(event){
                var target = event.currentTarget;
                if ((target) && (target.id) && (target.id.indexOf("_") >= 0)) {
                    var vtabIndex = parseInt(target.id.substring(target.id.indexOf("_") + 1));
                    var iconObj = this.querySelector('#icon_'+vtabIndex);
                    iconObj.style = this._getVtabIconStyle(vtabIndex, this.selectedIndex,this.colorSelected,this.colorUnselected,this.colorDisabled,this.isExpanded, this._refreshCtr,true);
                    iconObj.style.backgroundColor = this.iconHoverColor;
                }
            },

            /** Restores the style **/
            _outStyle: function(event){
                var target = event.currentTarget;
                if ((target) && (target.id) && (target.id.indexOf("_") >= 0)) {
                    var vtabIndex = parseInt(target.id.substring(target.id.indexOf("_") + 1));
                    var iconObj = this.querySelector('#icon_'+vtabIndex);
                    iconObj.style = this._getVtabIconStyle(vtabIndex, this.selectedIndex,this.colorSelected,this.colorUnselected,this.colorDisabled,this.isExpanded, this._refreshCtr,false);
                }
            },
            _focusOutHdlr: function(event){
                this.isExpanded = false;
            },
            _vtabClickHdlr: function(event){
                var target = event.currentTarget;
                if ((target) && (target.id) && (target.id.indexOf("_") >= 0)) {
                    var vtabIndex = parseInt(target.id.substring(target.id.indexOf("_") + 1));
                    if (this.isResetOnTabSelectEnabled(vtabIndex)){
                        this.fire('app_reset');
                        return;
                    }
                    var vtab = this._vtabItems[vtabIndex];
                    if (this.isVtabEnabled(vtabIndex)) {
                        if (!this._htabClicked) {

                            var htabContainer = this._getHtabContainer(vtabIndex);
                            if (htabContainer) {
                                if (this.autoExpand && !vtab.noChildTabsInMenu) {
                                    this.isExpanded = true;
                                } else {
                                    this.isExpanded = false;
                                }
                                if (this.autoZeroHtabIndex) {
                                    htabContainer.selectedIndex = 0; // automatically go to home page
                                }
                            } else {
                                // not htab children for this tab, so don't expand the vtabs
                                this.isExpanded = false;
                            }
                            this.selectedIndex = vtabIndex;
                        }
                        this._htabClicked = false;
                        if ((this._vtabItems) && (this._vtabItems.length > vtabIndex)) {
                            if ((vtab) && (vtab.tabClickCallback)) {
                                vtab.tabClickCallback(this, vtabIndex);
                            }
                        }
                        this.fire("vtab_click", {vtabIndex: vtabIndex});
                    }
                    this._refreshCtr++;
                }
            },
            _htabClicked: false,
            _htabClickHdlr: function(event){
                var target = event.currentTarget;
                if ((target) && (target.id) && (target.id.indexOf("_") >= 0)) {
                    try {
                        var htabIndex = parseInt(target.id.substring(target.id.indexOf(".") + 1));
                        var vtabIndex = parseInt(target.id.substring(target.id.indexOf("_") + 1,target.id.indexOf(".")));
                        var htabContainer = this._getHtabContainer(vtabIndex);
                        if ((this.isVtabEnabled(vtabIndex)) && (htabContainer.isTabEnabled(htabIndex))) {
                            this._htabClicked = true;
                            htabContainer.selectedIndex = htabIndex;
                            if ((htabContainer._tabItems) && (htabContainer._tabItems.length > htabIndex)) {
                                var tab = htabContainer._tabItems[htabIndex];
                                if ((tab) && (tab.tabClickCallback)) {
                                    tab.tabClickCallback(this, htabIndex);
                                }
                            }
                            this.selectedIndex = vtabIndex; // update this after the htabContainer.selectedIndex so that htab styles are properly rendered
                            this.fire("tab_click", {tabIndex: htabIndex});
                            this.isExpanded = false;
                        }
                        this._refreshCtr++;
                    }
                    catch(ex){
                        console.log("exception in htabClickHdlr: ex="+ex);
                    }
                }
            },
            _isInitCompleteChanged: function(newValue, oldValue){
                this._refreshCtr = 1000;
                // Polymer.updateStyles();
            },
            _getIronPagesStyle: function(hideVtabMenu) {
                var result = "margin-left:50px;";
                if (hideVtabMenu){
                    result = "margin-left:0;"
                }
                return result;
            },
            getNumTabs: function(){
                return this._vtabLabels.length;
            },
            getIndexForChild: function(tab){
                var result = -1;
                if ((this._vtabItems) && (this._vtabItems.length > 0)){
                    for (var i=0; i < this._vtabItems.length; i++){
                        if (this._vtabItems[i] === tab){
                            result = i;
                            break;
                        }
                    }
                }
                return result;
            },
            getChildTab: function(tabIndex){
                var result = null;
                if ((this._vtabItems) && (this._vtabItems.length > tabIndex)){
                    result = this._vtabItems[tabIndex];
                }
                return result;
            },
            _getVtab: function(vtab_index){
                var result = null;
                var items = this.queryAllEffectiveChildren("ti-widget-vtab");
                if ((items) && (vtab_index < items.length)) {
                    result = items[vtab_index];
                }
                return result;
            },
            _getHtab: function(vtab_index,htab_index){
                var htabs = this._getHtabs(vtab_index,this._vtabLabels);
                var result = null;
                if ((htab_index < htabs.length) && (htab_index >= 0)){
                    result = htabs[htab_index];
                }
                return result;
            },
            // this function is here just to allow the view to be properly refreshed when _refreshCtr is incremented.
            _getVtabLabels: function(_vtabLabels,_refreshCtr){
                return this._vtabLabels;
            },
            _getVtabMenuStyle: function(vtab_index,selectedIndex,_refreshCtr){
                var result = "color:black;";
                if (vtab_index === selectedIndex){
                    result += "font-weight:bold;"
                } else {
                    result += "opacity:0.8;"
                }
                return result;
            },
            _getVtabStyle: function(vtab_index,selectedIndex,vtabHeightInPx,isExpanded,_refreshCtr){
                var vtabRect = document.querySelector('#vtabs').getBoundingClientRect();

                var h = vtabRect.height;
                if ((this._vtabLabels) && (this._vtabLabels.length > 0)){
                    h = Math.trunc(vtabRect.height/this._vtabLabels.length);
                }
                if ((vtabHeightInPx) && (vtabHeightInPx > 0)){
                    h = vtabHeightInPx;
                }
                if (isExpanded){
                    var htabs = this._getHtabItems(vtab_index,this._vtabLabels,_refreshCtr);
                    if ((htabs) && (htabs.length > 1)){
                        h = 20+(40*htabs.length);
                    }
                }
                var result = "padding-top:10px;height:"+ h+"px;border-right:none;";
                if (this.isInitComplete) {
                    if (this.isVtabEnabled(vtab_index)) {
                        if (vtab_index === selectedIndex) {
                            result += "border-right:solid 2px " + this.colorSelectionBar + ";color:" + this.colorSelected + ";";
                        } else {
                            result += "color:" + this.colorUnselected + ";";
                        }
                    } else {
                        result += "color:" + this.colorDisabled + ";";
                    }
                } else {
                    result += "color: transparent;";
                }
                return result;
            },
            _getHtabContainer: function(vtabIndex){
                var result = null;
                var vtab = this._getVtab(vtabIndex);
                if (vtab) {
                    var htabs = this._getHtabs(vtabIndex, vtab._tabLabels);
                    if ((htabs) && (htabs.length > 0)) {
                        result = htabs[0].parentElement;
                        while ((result) && (result.localName !== 'ti-widget-tabcontainer') && (result.localName !== 'body')) {
                            result = result.parentElement;
                        }
                    }
                }
                return result;
            },
            _getHtabStyle: function(vtab_index,selectedIndex,colorSelected,colorUnselected,colorDisabled,_vtabLabels,vtabHeightInPx,htab,htab_index,_refreshCtr){
                var htabs = this._getHtabItems(vtab_index,this._vtabLabels,_refreshCtr);
                var htabContainer = this._getHtabContainer(vtab_index);
                var isIcon = this._isHtabIcon(htab,htab_index);
                var numHtabs = 1;
                if ((htabs) && (htabs.length > 0)){
                    numHtabs = htabs.length;
                }
                var vtabRect = document.querySelector('#vtabs').getBoundingClientRect();
                var h = vtabRect.height;
                if ((this._vtabLabels) && (this._vtabLabels.length > 0)){
                    h = vtabRect.height/this._vtabLabels.length
                }
                if ((this.vtabHeightInPx) && (this.vtabHeightInPx > 0)){
                    h = this.vtabHeightInPx;
                }
                h = h / numHtabs;

                var result = "htab height:"+ h+"px;";
                if (!isIcon) {
                    result += "padding-left:15px;"
                }

                if ((htabContainer) && (htabContainer.isTabEnabled(htab_index,_refreshCtr)) && this.isVtabEnabled(vtab_index)) {
                    if ((vtab_index === selectedIndex) && (htab_index === htabContainer.selectedIndex)) {
                        result += "background-color:transparent;color:" + this.colorSelected + ";";
                    } else {
                        result += "background-color:transparent;color:"+this.colorUnselected+";";
                    }
                } else {
                    result += "background-color:transparent;color:"+this.colorDisabled+";";
                }
                return result;
            },
            _getHtabFontColor: function(vtab_index,selectedIndex,htab_index,colorSelected,colorUnselected,colorDisabled,_refreshCtr){
                var result = this.colorUnselected;
                var htabContainer = this._getHtabContainer(vtab_index);
                if ((htabContainer) && (htabContainer.isTabEnabled(htab_index,_refreshCtr))) {
                    if ((vtab_index === selectedIndex) && (htab_index === htabContainer.selectedIndex)) {
                        result = this.colorSelected;
                    } else {
                        result = this.colorUnselected;
                    }
                } else {
                    result = this.colorDisabled;
                }
                return result;
            },
            _getVtabBackground: function(vtab_index,selectedIndex){
                var result = "white;";
                if (vtab_index === selectedIndex){
                    result = "lightgrey;";
                }
                var vtabRect = document.querySelector('#vtabs').getBoundingClientRect();

                var h = vtabRect.height;
                if ((this._vtabLabels) && (this._vtabLabels.length > 0)){
                    h = vtabRect.height/this._vtabLabels.length
                }
                var hs = "height:"+ h+"px;";
                return result+hs;
            },
            _isVtabVisible: function(vtab_index,_refreshCtr){
                var result = true;
                if ((this._vtabItems) && (this._vtabItems.length > vtab_index) && (this._vtabItems[vtab_index].nonvisible)) {
                    result = false;
                }
                return result;
            },
            _isVtabIcon: function(vtab_index,_refreshCtr){
                var result = false;
                if ((this._vtabIcons) && (this._vtabIcons[vtab_index]) && (this._vtabIcons[vtab_index].length > 0)) {
                    result = true;
                }
                return result;
            },
            _getVtabIcon: function(vtab_index,_refreshCtr){
                var result = "cancel";
                if (this._isVtabIcon(vtab_index,_refreshCtr)) {
                    result = this._vtabIcons[vtab_index];
                }
                return result;
            },
            _getVtabIconStyle: function(vtab_index,selectedIndex,colorSelected,colorUnselected,colorDisabled,isExpanded,_refreshCtr,isHover){
                var result = "";
                if ((this._vtabIconStyles) && (this._vtabIconStyles[vtab_index]) && (this._vtabIconStyles[vtab_index].length > 0)) {
                    result = this._vtabIconStyles[vtab_index];
                }
                if (this.isVtabEnabled(vtab_index)) {
                    if (vtab_index === Number(selectedIndex)) {
                        result += "color:" + colorSelected + ";";
                        if ((this.backgroundColorSelected !== "") && (!isHover)){
                            result += ";background-color:" + this.backgroundColorSelected +";border-radius:50%;"
                        }

                    } else {
                        result += "color:" + colorUnselected + ";";
                    }
                    if (isHover){
                        result += ";background-color:" + this.backgroundColorHover+";border-radius:50%;"
                    }
                } else {
                    result += "color:"+colorDisabled+";";
                }
                return result;
            },
            isResetOnTabSelectEnabled: function(vtab_index){
                var result = false;
                var vtab = this._getVtab(vtab_index);
                if (vtab) {
                    result = vtab.resetAppWhenSelected;
                }
                return result;
            },
            isVtabEnabled: function(vtab_index){
                var result = true;
                var vtab = this._getVtab(vtab_index);
                if (vtab) {
                    result = !vtab.disabled;
                }
                return result;
            },
            _getVtabCaption: function(vtab_index){
                var result = "";
                if ((this._vtabCaptions) && (this._vtabCaptions[vtab_index])) {
                    result = this._vtabCaptions[vtab_index];
                }
                return result;
            },
            _getVtabTooltip:function(vtab_index){
                var result = "";
                if ((this._vtabTooltips) && (this._vtabTooltips[vtab_index])) {
                    result = this._vtabTooltips[vtab_index];
                }
                return result;
            },
            _getHtabTooltip:function(vtab_index,htab_index){
                var result = "";
                var htab = this._getHtab(vtab_index,htab_index);
                if (htab) {
                    result = htab.tooltip;
                }
                return result;
            },
            _isHtabIcon: function(htab,htab_index){
                var result = false;
                if ((htab) && (htab.icon)) {
                    result = true;
                }
                return result;
            },
            swapItems: function(index1,index2){
                // remove higher index, then insert before lower index
                var lowIndex = index1;
                var highIndex = index2;
                if (lowIndex > highIndex){
                    lowIndex = index2;
                    highIndex = index1;
                }
                //var items = Polymer.dom(this).children;
                if (this._vtabItems) {
                    var lowItem = this._vtabItems[lowIndex];
                    var highItem = this._vtabItems[highIndex];
                    var highId = highItem.id;
                    var lowId = lowItem.id;
                    highItem.id = "tempxyz"+lowId;
                    lowItem.id = highId;
                    highItem.id = lowId;
                    var tmpItem = this._vtabItems[lowIndex];
                    this._vtabItems[lowIndex] = this._vtabItems[highIndex];
                    this._vtabItems[highIndex] = tmpItem;
                    Polymer.dom(Polymer.dom(highItem).parentNode).insertBefore(highItem, lowItem);
                    highItem.cleanChildClasses();
                    lowItem.cleanChildClasses();
                }

                this.refreshTabs();
                this.notifyPath("_vtabItems."+lowIndex);
                this.notifyPath("_vtabItems."+highIndex);
                this.notifyPath("_vtabLabels."+lowIndex);
                this.notifyPath("_vtabLabels."+highIndex);
                this.notifyPath("_vtabIcons."+lowIndex);
                this.notifyPath("_vtabIcons."+highIndex);
            },
            removeVtab: function(vtabIndex){
                var removedVtab = this._vtabItems[vtabIndex];
                try {
                    this.splice('_vtabItems', vtabIndex);
                    this.splice('_vtabLabels', vtabIndex);
                    this.splice('_vtabIcons', vtabIndex);
                }
                catch(ex1){
                    console.log(ex1);
                }
                try {
                    removedVtab.isDeleted = true;
                    var parentNode = Polymer.dom(removedVtab).parentNode;
                    Polymer.dom(parentNode).removeChild(removedVtab);
                }
                catch(ex){
                    console.log(ex);
                }
                this.refreshTabs();
            },
            _onVtabPropertyChanged: function(event){
                var detailsObj = event.detail;
                if (detailsObj){
                    var tab = detailsObj.tab;
                    if (tab && tab.localName === 'ti-widget-vtab'){
                        var tabIndex = tab.getTabIndex();
                        this._vtabLabels[tabIndex] = tab.name;
                        this._vtabIcons[tabIndex] = tab.icon;
                        this._vtabCaptions[tabIndex] = tab.caption;
                        this._vtabTooltips[tabIndex] = tab.tooltip;
                        this._vtabIconStyles[tabIndex] = tab.iconStyle;
                        this.fire("vtabItemChanged",{vtab: tab});
                    }
                }
            },
            onVtabPropertyChanged: undefined,
            _onVtabItemsChanged : function()
            {
                if (this._domReadyWasCalled) {
                    var nOldTabs = (this._vtabLabels && this._vtabLabels.length) || 0;
                    for (var j=0; j < this._vtabItems.length; j++){
                        this._vtabItems[j].removeEventListener('tabPropertyChanged',this.onVtabPropertyChanged);
                    }
                    this.splice('_vtabItems', 0, this._vtabItems.length);
                    this.splice('_vtabLabels', 0, this._vtabLabels.length);
                    this.splice('_vtabIcons', 0, this._vtabIcons.length);
                    this.splice('_vtabIconStyles', 0, this._vtabIconStyles.length);
                    this.splice('_vtabCaptions', 0, this._vtabCaptions.length);
                    this.splice('_vtabTooltips', 0, this._vtabTooltips.length);
                    var items = this.queryAllEffectiveChildren("ti-widget-vtab");
                    if (items) {
                      for (var i = 0; i < items.length; i++) {
                        var item = items[i];
                        if (item && !item.isDeleted) {
                                item.addEventListener('tabPropertyChanged',this.onVtabPropertyChanged);
                                this.push("_vtabItems",item);
                                this.push("_vtabLabels", item.name);
                                this.push('_vtabIcons', item.icon);
                                this.push('_vtabIconStyles', item.iconStyle);
                                this.push('_vtabCaptions', item.caption);
                                this.push('_vtabTooltips', item.tooltip);
                            }
                        }
                    }
                    var nNewTabs = (this._vtabLabels && this._vtabLabels.length) || 0;
                    if (nOldTabs > 0 && (nNewTabs > nOldTabs || this.selectedIndex >= nNewTabs)) {
                        // if vtabs are changing on the fly we must be in the designer, so lets set the selectedIndex
                        // to the last tab added in the designer so it is ready for editing.
                        this.selectedIndex = nNewTabs - 1;
                    }
                    for (var j = 0; j < items.length; j++) {
                        if (!item.isDeleted) {
                            this.notifyPath('_vtabItems.' + j);
                            this.notifyPath('_vtabIcons.' + j);
                            this.notifyPath('_vtabLabels.' + j);
                            this.notifyPath('_vtabIconStyles.' + j);
                            this.notifyPath('_vtabCaptions.' + j);
                            this.notifyPath('_vtabTooltips.' + j);
                        }
                    }
                    this.selectedLabel = this._vtabLabels[this.selectedIndex];

                }
            },
            onVtabItemsChanged: undefined,
            select: function(value){
                // override the iron-menu-behavior select function as this does not understand hidden items
                // and incorrectly sets the selectedIndex as a result.
            },
            _selectedIndexChanged: function(newValue, oldValue)
            {
                if (this.selectedIndex < 0) return;
                if (!this.isVtabEnabled(this.selectedIndex)){
                    this.selectedIndex = oldValue;
                } else {
                    if (this._vtabLabels) {
                        this.fire("before_selected_tab_changed", {
                            selectedIndex: this.selectedIndex,
                            selectedLabel: this.selectedLabel
                        });
                        if (this.selectedIndex >= 0 && this.selectedIndex < this._vtabLabels.length) {
                            this.selectedLabel = this._vtabLabels[this.selectedIndex];
                        }
                        this.fire("selected_tab_changed", {
                            selectedIndex: this.selectedIndex,
                            selectedLabel: this.selectedLabel
                        });
                    }
                }
            },
            _selectedLabelChanged: function(newValue, oldValue)
            {
                if (!newValue) return;
                var index = this._vtabLabels.indexOf(newValue);
                if (index >= 0) {
                    this.selectedIndex = index;
                }
            },
            _isExpandedChanged: function(newValue, oldValue){
                var vtabs =  document.querySelector('#vtabs');
                if (vtabs) {
                    vtabs.isExpanded = newValue;
                }
            },
            _getHtabItems: function(vtab_index,vtabLables,_refreshCtr){
                var vtab = this._getVtab(vtab_index);
                if (vtab.noChildTabsInMenu) return [];
                return this._getHtabs(vtab_index,this._vtabLabels);
            },
            _getHtabs: function(vtab_index,_vtabLabels){
                var result = [];
                var vtab = this._getVtab(vtab_index);
                if (vtab.children.length > 0) {
                    try {
                        var element = vtab.children[0];
                        if (element.localName === 'ti-widget-tabcontainer') {
                            result = element._tabItems;
                        }
                    }
                    catch (ex) {
                        console.log(ex)
                    }
                }
                return result;
            },
            _getHtabIcons: function(_refreshCtr,vtab_index,_vtabLabels){
                var result = [];
                var vtab = this._getVtab(vtab_index);
                if ((!vtab.noChildTabsInMenu) && (vtab.children.length > 0)){
                    try {
                        var element = vtab.children[0];
                        if (element.localName === 'ti-widget-tabcontainer') {
                            result = element._tabIcons;
                            for (var j = 0; j < result.length; j++) {
                                if (!result[j]) {
                                    result[j] = "ti-core-icons:keypad-question-mark";
                                }
                            }
                        }
                    }
                    catch(ex){
                        console.log(ex)
                    }
                }
                return result;
            },
            refreshStyles: function(){
                //bc optimize:
                //this.updateStyles();
                //Polymer.dom.flush();
                if ((this._refreshCtr === undefined) || (this._refreshCtr === null) || (isNaN(this._refreshCtr))) {
                    this._refreshCtr = 100;
                }
                this._refreshCtr++;
            },
            refreshTabs: function(refreshAllTabs){
                if (refreshAllTabs === true) {
                    this.onVtabItemsChanged();
                }
                this.refreshStyles();
            },
            created: function(){
                this.onVtabItemsChanged = this._onVtabItemsChanged.bind(this);
                this.onVtabPropertyChanged = this._onVtabPropertyChanged.bind(this);
            },
            attached: function() {
                this.async(function() {
                    this.domReady();
                }.bind(this),1);
            },
            selectedTabChangedHdlr: function(event){
                if ((event.target) && (event.target.id) && (event.target.id !== this.id)) {
                    this.isExpanded = false;
                }
            },
            _getTabIndex: function(vtab_index,isExpanded,_refreshCtr){
                return vtab_index;
            },
            _isDesignerHosted: function () {
                return gc.utils.isInDesigner();
            },
            processNewNodes: function(addedNodes){
                if (addedNodes && addedNodes.length > 0) {
                    if (addedNodes[0].localName !== 'ti-widget-vtab') return;
                    this.onVtabItemsChanged();
                    if (this._inDesigner) {
                        this.selectedIndex = 0;
                    }
                    //bc Polymer.updateStyles();
                    this._refreshCtr++;
                }
            },
            processRemovedNodes: function(removedNodes){
                if (removedNodes && removedNodes.length > 0) {
                    if (removedNodes[0].localName !== 'ti-widget-vtab') return;
                    this.onVtabItemsChanged();
                }
            },
            _inDesigner: false,
            domReady: function()
            {
                this._inDesigner = this._isDesignerHosted();
                this._domReadyWasCalled = true;
                this.isExpanded = false;
                this.splice('_vtabLabels', 0, this._vtabLabels.length);
                this.onVtabItemsChanged();
                // whenever e.g. a horizontal tab is selected while the vtab menu is expanded,
                // unexpand the menu so we don't end up displaying stale selection status for the child tabs
                this.addEventListener('selected_tab_changed',this.selectedTabChangedHdlr.bind(this));
                if (this._inDesigner) {
                    this._observer =
                        Polymer.dom(this.$.vtabPages).observeNodes(function (info) {
                            this.processNewNodes(info.addedNodes);
                            this.processRemovedNodes(info.removedNodes);
                        }.bind(this));
                }
                this.async(function(){
                    this.isInitComplete = true;
                }.bind(this),10);
            },
            detached: function(){
                this.removeEventListener('selected_tab_changed',this.selectedTabChangedHdlr.bind(this));
            },
            ready: function() {
                this._selectedIndexChanged();
            }
        });
    </script>
</dom-module>
